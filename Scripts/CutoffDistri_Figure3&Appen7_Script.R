##====================-- I Set up Environment ----
## Notes: This script involves computationally expensive iterations,
## and thus results can only be generated by using high-performance
## computing clusters (HPCs). 
##----
## 1.1 load packages ----
rm(list=ls())

pkgs <- c( "tidyverse", "pals","ggpubr", "ggsci", "xgboost",
           "Ckmeans.1d.dp", "devtools", "R.utils", 
           "ggh4x", "SHAPforxgboost","scales", "uwot", "caret",
           "QCA", "SetMethods", "venn", "cna", "haven", "gtools")

lapply(pkgs, require, character.only = TRUE)

## 1.2 load auxiliary script ----
source("Scripts/Utility/General_Utility.R")
source("Scripts/Utility/cluster_diag_hotfix.R")


##----
##====================-- I Cutoff Distribution Studies: Crisp Set ---- Figure 3
##----
## 1.1 reload data ----
set.seed(201)
xgbList <- readRDS("Results/xgb_dataList.rds")
list2env(xgbList, .GlobalEnv)

## 1.2 re-calibrate using top xgboost threshold ----
subDataRC <- reCalibrateXGCut(dataNoNA, cutDf = cutDf, "vote", na.rm = F)

## 1.3 find xgboost-based QCA solutions ----
## we first iterate through top 10 conditions choose 4 with the xgboost-derived cutoffs
## this gives a table with ranked solutions
bestThQCA <- combnQCA(Nvec = c(1:10), k = 4, dfInput = subDataRC, Lab = "vote", 
                      fImpDf = fDf, incl.cut = 0.8)
bestThQCA$ID <- paste0("Rank", bestThQCA$rank)

## 1.4 compare these agianst alternative calibrations ----
## here we focus on top 10 solutions as illustrations
## we check for each of Top 10 solutions, what alternative thresholds would produce

TopNsol <-  10 # change this number to see more or fewer distributions

### 1.4.1 for each of Top 10 solutions, obtain all the possible threshold combinations
threshDfList <- list()
for (ix in c(1:TopNsol)){
  idxSet <- bestThQCA$index[ix]
  idxSet <- as.numeric(strsplit(idxSet, ",")[[1]])
  fDfsort <- fDf %>% arrange(desc(shap))
  vSelect <- fDfsort$feature[idxSet]
  threshDf<- crossThresh(dataDf = data, fVec = vSelect, NcutMax = Inf)
  threshDf <- threshDf[,vSelect]
  
  rlab <- paste0("Rank", ix)
  threshDfList[[rlab]] <- threshDf
}

### 1.4.2 for each solution's alternative thresholds, we re-calibrate data and perform QCA
### warning: some solutions have extremely large thresold combinations
### this require large memory and extensive computational resources
resList <- lapply(1:TopNsol, function(ix){
  threshDf <- threshDfList[[ix]]
  idxSet <- bestThQCA$index[ix]
  idxSet <- as.numeric(strsplit(idxSet, ",")[[1]])
  fDfsort <- fDf %>% arrange(desc(shap))
  vSelect <- fDfsort$feature[idxSet]
  cutDfTemp <- as.data.frame(cutDf)
  rownames(cutDfTemp) <- cutDfTemp$feature
  
  subDataRCList <- lapply(1:nrow(threshDf), function(nx){
    cutDfx <- cutDfTemp
    cutDfx[vSelect, "cutoff"] <- data.matrix(threshDf)[nx, ]
    reCalibrateXGCut(data, cutDf = cutDfx, "vote", na.rm = F)
  })
  
  altQCAList <- lapply(subDataRCList, function(subdfx){
    tryCatch({
      subsetSufficiency(dfInput=subdfx, rankVec=idxSet, 
                        Lab="vote", fImpDf=fDf, incl.cut=0.8)
    }, error = function(e){
      return(NULL)
    })
  })
  
  idxList <- rep(list(idxSet), length(altQCAList))
  
  sumSuffList(idxList, altQCAList)
})
names(resList) <- paste0("Rank", 1:TopNsol)


### 1.4.3 determine xgboost-solution ranking 
### we then determine among all the alternative threshold solutions, where does the xgboost-derived one stands
### "rInAlt"= ranking in alternative; "qInAlt" = "quantile in alternative"
bestThQCA$rInAlt <- 0
bestThQCA$qInAlt <- 0
for (ix in 1:TopNsol){
  rlab <- paste0("Rank", ix)
  rawConvS <- bestThQCA$convS[ix]
  altQCADfx <- resList[[rlab]]
  closetIdx <- which.min(abs( altQCADfx$convS - rawConvS ))
  bestThQCA[ix, "rInAlt"] <- altQCADfx$rank[closetIdx] 
  bestThQCA[ix, "qInAlt"] <- 1 - as.numeric(altQCADfx$rank[closetIdx] )/nrow(altQCADfx)
}

### 1.4.4 Finally we plot the distribution ----
IdxToPlot <- 1:TopNsol ## change this index set to decide which distributions to plot

dfx <- bind_rows(lapply(IdxToPlot, function(ii){
  lx <- paste0("Rank", 1:TopNsol)[ii]
  resDfx <- resList[[lx]]
  resDfx$ID <- lx
  resDfx
}))

dfx$ID <- factor(dfx$ID, levels = mixedsort(unique(dfx$ID)))
bestThQCA$ID <- paste0("Rank", bestThQCA$rank)
segDf <- bestThQCA[1:length(resList),]
segDf$ID <- factor(segDf$ID, levels = mixedsort(unique(dfx$ID)))


p1c <- ggplot(dfx, aes(x=convS)) +
  geom_histogram(aes(y=..density..), color="grey60", fill="white", binwidth = 0.02) +
  geom_density(alpha=0.2, fill="dodgerblue") +
  geom_segment(data = segDf, aes(x = convS, xend=convS), y=0, 
               yend=Inf, color="red", size=1)+
  facet_wrap(~ID, nrow = 3, scales = "free_y") +
  scale_x_continuous(limits = c(0,1)) +
  theme_pubr() +
  labs(x="Coverage", y="density") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        axis.title.x = element_text(size=14),
        axis.title.y = element_text(size=14),
        strip.background = element_rect(fill = "transparent", 
                                        color = "transparent"),
        strip.text = element_text(size=12, face="bold"))
saveFig(p1c, prefix = "Results/Plot_ShapTop10_10Choose4_Threshold_Distribution_CripSet", 
        wd = 2400, ht = 2000)


##----
##====================-- II cutoff Distribution Studies: Fuzzy Set ---- Appendix 7
##----
## 2.1 reload data ----
set.seed(201)
xgbList <- readRDS("Results/xgb_dataList.rds")
list2env(xgbList, .GlobalEnv)

## 2.2 re-calibrate using top xgboost threshold ----
subDataRC <- reCalibrateXGCutFuzzy(dfInput = dataNoNA, cutDf = cutDfFull, Lab = "vote", method = "direct")

## 2.3 find xgboost-based QCA solutions ----
## we first iterate through top 10 conditions choose 4 with the xgboost-derived cutoffs
## this gives a table with ranked solutions
bestThQCA <- combnQCA(Nvec = c(1:10), k = 4, dfInput = subDataRC, Lab = "vote", 
                      fImpDf = fDf, incl.cut = 0.8)
bestThQCA$ID <- paste0("Rank", bestThQCA$rank)

## 2.4 compare these against alternative calibrations ----
## here rather than search for threshold set based on solutions, we generate it for each variable directly
## this is due to the large number of possible fuzzy calibrations; to make it more memory efficient

### 2.4.1 check among top 10 conditions how many possible thresholds each has
### pick only those with more than 3 thresholds; which are then relevant for alternative fuzzy calibration
FTop10 <- fDf %>% 
  arrange(desc(shap)) %>% 
  slice_head(n=10) %>%
  pull(feature)
FTop10_thresh <- lapply(FTop10, function(fx) getFthresh(dataDf = data, fname = fx, NcutMax = Inf))
names(FTop10_thresh) <- FTop10
thLen <- sapply(FTop10_thresh, length)

fSelect <- names(thLen[thLen>3])
tSelect <- FTop10_thresh[fSelect]

### 2.4.2 for reach selected condition, create cutDf fragments to plug in later
cutDfList <- list()
for (fx in fSelect){
  tVec <- sort(tSelect[[fx]])
  
  tList <- combn(tVec, 3, simplify = F)
  sN <- min(c(length(tList), 1000))
  subList <- sample(tList, sN)
  dfFragList <- lapply(subList, function(tx){
    data.frame(feature = rep(fx, 3),
               cutoff = tx, 
               n = c(3:1),
               Prop = c(0.8,0.6,0.4))
  })
  cutDfList[[fx]] <- dfFragList
}

### 2.4.3 we then select the solutions that contain these relevant conditions
ixSelect <- which(sapply(1:15, function(ix){
  ## feature in the row
  idxSet <- bestThQCA$index[ix]
  idxSet <- as.numeric(strsplit(idxSet, ",")[[1]])
  fDfsort <- fDf %>% arrange(desc(shap))
  vSelect <- fDfsort$feature[idxSet]
  any(vSelect %in% names(cutDfList))
}))


### 2.4.4 for each solution, we iterate all the alternative calibrations for the fuzzy-relavant variables
### the non-relevant ones were kept the same since there is no alternative fuzzy calibration
### warning: some solutions have extremely large thresold combinations
### this require large memory and extensive computational resources
resList <- lapply(ixSelect, function(ix){
  ## feature in the row
  idxSet <- bestThQCA$index[ix]
  idxSet <- as.numeric(strsplit(idxSet, ",")[[1]])
  fDfsort <- fDf %>% arrange(desc(shap))
  vSelect <- fDfsort$feature[idxSet]
  
  vToFuzzy <- sample(vSelect[vSelect %in% names(cutDfList)],1)
  vCutDfList <- cutDfList[[vToFuzzy]]
  
  subDataRCList <- lapply(vCutDfList, function(cx){
    cutDfx <- cutDf %>% filter(feature!=vToFuzzy)
    cutDfx <- bind_rows(cutDfx, cx)
    reCalibrateXGCutFuzzy(dfInput = data, cutDf = cutDfx, Lab = "vote", method = "direct")
  })
  
  altQCAList <- lapply(subDataRCList, function(subdfx){
    tryCatch({
      subsetSufficiency(dfInput=subdfx, rankVec=idxSet, 
                        Lab="vote", fImpDf=fDf, incl.cut=0.8)
    }, error = function(e){
      return(NULL)
    })
  })
  
  idxList <- rep(list(idxSet), length(altQCAList))
  
  sumSuffList(idxList = idxList, resList = altQCAList)
})
names(resList) <- paste0("Rank", ixSelect)


### 2.4.5 determine xgboost-solution ranking 
### we then determine among all the alternative threshold solutions, where does the xgboost-derived one stands
### "rInAlt"= ranking in alternative; "qInAlt" = "quantile in alternative"
bestThQCA$rInAlt <- 0
bestThQCA$qInAlt <- 0
for (ix in ixSelect){
  rlab <- paste0("Rank", ix)
  rawConvS <- bestThQCA$convS[ix]
  altQCADfx <- resList[[rlab]]
  closetIdx <- which.min(abs( altQCADfx$convS - rawConvS ))
  bestThQCA[ix, "rInAlt"] <- altQCADfx$rank[closetIdx] 
  bestThQCA[ix, "qInAlt"] <- 1 - as.numeric(altQCADfx$rank[closetIdx] )/nrow(altQCADfx)
}

### 2.4.6 Finally we plot the distribution ----
IdxToPlot <- ixSelect ## change this index set to decide which distributions to plot

dfx <- bind_rows(lapply(IdxToPlot, function(ii){
  lx <- paste0("Rank", ixSelect)[ii]
  resDfx <- resList[[lx]]
  resDfx$ID <- lx
  resDfx
}))

dfx$ID <- factor(dfx$ID, levels = mixedsort(unique(dfx$ID)))
bestThQCA$ID <- paste0("Rank", bestThQCA$rank)
segDf <- bestThQCA[1:length(resList),]
segDf$ID <- factor(segDf$ID, levels = mixedsort(unique(dfx$ID)))


p1c <- ggplot(dfx, aes(x=convS)) +
  geom_histogram(aes(y=..density..), color="grey60", fill="white", binwidth = 0.02) +
  geom_density(alpha=0.2, fill="dodgerblue") +
  geom_segment(data = segDf, aes(x = convS, xend=convS), y=0, 
               yend=Inf, color="red", size=1)+
  facet_wrap(~ID, nrow = 3, scales = "free_y") +
  scale_x_continuous(limits = c(0,1)) +
  theme_pubr() +
  labs(x="Coverage", y="density") +
  theme(axis.text.x = element_text(size=12),
        axis.text.y = element_text(size=12),
        axis.title.x = element_text(size=14),
        axis.title.y = element_text(size=14),
        strip.background = element_rect(fill = "transparent", 
                                        color = "transparent"),
        strip.text = element_text(size=12, face="bold"))
saveFig(p1c, prefix = "Results/Plot_ShapTop10_10Choose4_Threshold_Distribution_Fuzzy", 
        wd = 2400, ht = 2000)
